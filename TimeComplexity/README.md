# 01-1 시간복잡도 표기법

## 시간복잡도

- 알고리즘에서 시간복잡도란 주어진 문제를 해결하기 위한 연산 횟수를 의미
- 수행시간은 1억 번의 연산을1초의 시간으로 간주하여 예측

## 시간복잡도 유형

- Ω(n) : 빅-오메가
  - 최선일 때 연산횟수를 나타낸 표기법

- Θ(n) : 빅-세타
  - 보통일 때 연산횟수를 나타낸 표기법

- Ο(n) : 빅-오
  - 최악일 때 연산횟수를 나타낸 표기법


## 시간복잡도 도출 기준

- 상수는 시간 복잡도 계산에서 제외한다.
- 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

# 디버깅

## 디버깅이란

- 발생하는 문법 오류나 논리 오류를 찾아 바로잡는 과정을 디버깅이라고 함
- 내 판단 : 디버깅은 (LLM으로 처리하면 가볍게 해결되고, 실제로는 직접 경험하면서 깨달아가야 하는 문제)

# 자료구조

## 3.1 배열과 리스트

- 배열
  - 메모리의 연속공간에 값이 채워져 있는 형태의 자료구조
  - 배열의 값은 인덱스를 통해 참조할 수 있음
  - 선언한 자료형의 값만 저장가능
- 리스트
  - 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조

## 3.2 구간합

- 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘
- 합 배열 S 의 정의
  - S[i] = A[0] + A[1] + A[2] + ... + A[i-1] + A[i]

- 구간 합 정의
  - S[5] - (A[0] + A[1]) = S[2~5]

- 2차원 구간합
  - D[x1, y1] ~ D[x2, y2] : D[x2,y2] - D[x1,y2] - D[x2,y1] + D[x1,y1]
  - NxN인 배열 (N = 4로 가정)
  - D[2,2] ~ D[3,4] -> D[3,4] - D[2,4] - D[3,2] + D[2,2]

- 나머지 구간합
  - (A + B) % C = ((A % C) + (B % C)) % C
  - S[i] = S[i-1] + A[i]
  - S[i] - S[j] = j+1부터 i까지의 구간합 (이 개념 사용)
    - 따라서 S[i] 와 S[j] 가 같은 나머지의 개수를 통해 나올 수 있는 경우의 수를 구하면 나머지의 개수를 구할 수 있다.

## 3.3 투 포인터

- 2개의 포인터로 알고리즘의 시간 복잡도를 최적화함.
- start_index, end_index 2개의 포인터를 두어 문제를 풀이하는 방식 (이 알고리즘은 그냥 직관적으로 해결하는 것)

# 3.4 슬라이딩 윈도우

- 2개의 포인터로 범위를 지정한 다음 범위를 유지한 채로 이동하며 문제를 해결
- 투 포인터 알고리즘과 비슷함

# 3.5 스택과 큐

- 스택 : 삽입과 삭제 연산이 후입선출(LIFO)로 이뤄지는 자료구조
  - top : 삽입과 삭제가 일어나는 위치
  - push : top 위치에 새로운 데이터를 삽입하는 연산
  - pop : top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
  - peek : top 위치에 현재 있는 데이터를 단순 확인하는 연산

  - 깊이 우선 탐색(DFS : Depth First Search), 백트래킹 종류의 코테에 효과적 (재귀함수 알고리즘 원리와 일맥상통)

- 큐 : 삽입과 삭제 연산이 선입선출(FIFO)로 이뤄지는 자료구조
  - rear : 큐에서 가장 끝 데이터를 가리키는 영역
  - front : 큐에서 가장 앞의 데이터를 가리키는 영역
  - add : rear부분에 새로운 데이터를 삽입하는 연산
  - poll : front 부분에 있는 데이터를 삭제하고 확인하는 연산
  - peek : 큐의 맨 앞에 있는 데이터를 확인할 때 사용하는 연산

  - 너비 우선 탐색(BFS : Breadth First Search)에서 자주 사용

# 정렬

- 정렬 알고리즘 종류
  - 버블 : 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식
  - 선택 : 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식
  - 삽입 : 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식
  - 퀵 : pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식
  - 병합 : 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식
  - 기수 : 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식

## 4.1 버블정렬

- 두 인접한 데이터의 크기를 비교해 정렬하는 방법
- 시간 복잡도 = Ο(n²)
``` java
for (int i=0; i<N; i++) {
  for (int j=0; j<N-i; j++) {
    // j끼리 비교해서 찾는 방식
  }
}
```
  
## 4.2 선택정렬

- 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
- 구현 방법이 복잡하고, 시간복잡도 = Ο(n²)
``` java
for (int i=0; i<N; i++) {
  for (int j=i+1; j<N; j++) {
    // i와 j를 같이 비교해서 찾는 방식
  }
}
```


## 4.3 삽입 정렬

- 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
- 시간 복잡도 = Ο(n²)
- 참고 : 적절한 위치를 탐색하는 부분에서 이진탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있음
``` java
for (int i=1; i<N; i++) {
  int insert_index = i;
  int insert_value = A[i];
  for (int j=i-1; j>=0; j--) {
    // 삽입해야할 대상부터 아래로 내려가면서 찾는 방식
  }
}
```

## 4.4 퀵 정렬

- 기준값을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘
- 기준값이 어떻게 선정되는지가 시간복잡도에 많은 영향을 끼침
- 평균적인 시간 복잡도 = Ο(nlogn)
- 최악 시간 복잡도 = Ο(n²)
```
코드로 설명은.. 직접 혼자서 풀 수 있게 되었을 때..
hint : 분할과 정복, 재귀
```

## 4.5 병합 정렬

- 분할 정복 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘
- 평균적인 시간 복잡도 = Ο(nlogn)
```
코드로 설명은.. 직접 혼자서 풀 수 있게 되었을 때..
hint : 분할과 정복, 재귀
```