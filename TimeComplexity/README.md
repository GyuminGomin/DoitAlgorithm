# 01-1 시간복잡도 표기법

## 시간복잡도

- 알고리즘에서 시간복잡도란 주어진 문제를 해결하기 위한 연산 횟수를 의미
- 수행시간은 1억 번의 연산을1초의 시간으로 간주하여 예측

## 시간복잡도 유형

- Ω(n) : 빅-오메가
  - 최선일 때 연산횟수를 나타낸 표기법

- Θ(n) : 빅-세타
  - 보통일 때 연산횟수를 나타낸 표기법

- Ο(n) : 빅-오
  - 최악일 때 연산횟수를 나타낸 표기법


## 시간복잡도 도출 기준

- 상수는 시간 복잡도 계산에서 제외한다.
- 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

# 디버깅

## 디버깅이란

- 발생하는 문법 오류나 논리 오류를 찾아 바로잡는 과정을 디버깅이라고 함
- 내 판단 : 디버깅은 (LLM으로 처리하면 가볍게 해결되고, 실제로는 직접 경험하면서 깨달아가야 하는 문제)

# 자료구조

## 3.1 배열과 리스트

- 배열
  - 메모리의 연속공간에 값이 채워져 있는 형태의 자료구조
  - 배열의 값은 인덱스를 통해 참조할 수 있음
  - 선언한 자료형의 값만 저장가능
- 리스트
  - 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조

## 3.2 구간합

- 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘
- 합 배열 S 의 정의
  - S[i] = A[0] + A[1] + A[2] + ... + A[i-1] + A[i]

- 구간 합 정의
  - S[5] - (A[0] + A[1]) = S[2~5]

- 2차원 구간합
  - D[x1, y1] ~ D[x2, y2] : D[x2,y2] - D[x1,y2] - D[x2,y1] + D[x1,y1]
  - NxN인 배열 (N = 4로 가정)
  - D[2,2] ~ D[3,4] -> D[3,4] - D[2,4] - D[3,2] + D[2,2]

- 나머지 구간합
  - (A + B) % C = ((A % C) + (B % C)) % C
  - S[i] = S[i-1] + A[i]
  - S[i] - S[j] = j+1부터 i까지의 구간합 (이 개념 사용)
    - 따라서 S[i] 와 S[j] 가 같은 나머지의 개수를 통해 나올 수 있는 경우의 수를 구하면 나머지의 개수를 구할 수 있다.

## 3.3 투 포인터

- 2개의 포인터로 알고리즘의 시간 복잡도를 최적화함.
- start_index, end_index 2개의 포인터를 두어 문제를 풀이하는 방식 (이 알고리즘은 그냥 직관적으로 해결하는 것)

# 3.4 슬라이딩 윈도우

- 2개의 포인터로 범위를 지정한 다음 범위를 유지한 채로 이동하며 문제를 해결
- 투 포인터 알고리즘과 비슷함